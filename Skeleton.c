/* File generated by the BNF Converter (bnfc 2.9.5). */

/*** Visitor Traversal Skeleton. ***/
/* This traverses the abstract syntax tree.
   To use, copy Skeleton.h and Skeleton.c to
   new files. */

#include <stdlib.h>
#include <stdio.h>

#include "Skeleton.h"

void visitProgram(Program p)
{
  switch(p->kind)
  {
  case is_Prog:
    /* Code for Prog Goes Here */
    printf("Começando a análise semântica\n");
    visitListDecl(p->u.prog_.listdecl_);
    visitListStm(p->u.prog_.liststm_);
    visitListFunction(p->u.prog_.listfunction_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Program!\n");
    exit(1);
  }
}

void visitFunction(Function p)
{
  switch(p->kind)
  {
  case is_Fun:
    /* Code for Fun Goes Here */
    visitIdent(p->u.fun_.ident_);
    visitListStm(p->u.fun_.liststm_1);
    visitListStm(p->u.fun_.liststm_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Function!\n");
    exit(1);
  }
}

void visitDecl(Decl p)
{
  switch(p->kind)
  {
  case is_Dec:
    /* Code for Dec Goes Here */
    visitType(p->u.dec_.type_);
    visitListIdent(p->u.dec_.listident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Decl!\n");
    exit(1);
  }
}

void visitListFunction(ListFunction listfunction)
{
  while(listfunction  != 0)
  {
    /* Code For ListFunction Goes Here */
    visitFunction(listfunction->function_);
    listfunction = listfunction->listfunction_;
  }
}

void visitListStm(ListStm liststm)
{
  while(liststm  != 0)
  {
    /* Code For ListStm Goes Here */
    visitStm(liststm->stm_);
    liststm = liststm->liststm_;
  }
}

void visitListDecl(ListDecl listdecl)
{
  while(listdecl  != 0)
  {
    /* Code For ListDecl Goes Here */
    visitDecl(listdecl->decl_);
    listdecl = listdecl->listdecl_;
  }
}

void visitListIdent(ListIdent listident)
{
  while(listident  != 0)
  {
    /* Code For ListIdent Goes Here */
    visitIdent(listident->ident_);
    listident = listident->listident_;
  }
}

void visitStm(Stm p)
{
  switch(p->kind)
  {
  case is_SDecl:
    /* Code for SDecl Goes Here */
    visitDecl(p->u.sdecl_.decl_);
    break;
  case is_SExp:
    /* Code for SExp Goes Here */
    visitExp(p->u.sexp_.exp_);
    break;
  case is_SBlock:
    /* Code for SBlock Goes Here */
    visitListStm(p->u.sblock_.liststm_);
    break;
  case is_SWhile:
    /* Code for SWhile Goes Here */
    visitExp(p->u.swhile_.exp_);
    visitStm(p->u.swhile_.stm_);
    break;
  case is_SFor:
    /* Code for SFor Goes Here */
    printf("Verificando o FOR \n");

    printf("Verificando comando de inicialização do FOR\n");
    if (p->u.sfor_.exp_1->kind != is_EAss &&  
        p->u.sfor_.exp_1->kind != is_EAssSimpl) 
    {
        printf("Erro: Inicialização do 'for' inválida. Deve ser uma expressão de atribuição.\n");
        break;
    }
    else {
      printf("Inicialização do for válida\n");
    }
    visitExp(p->u.sfor_.exp_1);

    printf("Verificando comando de condição do FOR\n");
    if (p->u.sfor_.exp_2->kind != is_ELt &&   
        p->u.sfor_.exp_2->kind != is_Equal &&  
        p->u.sfor_.exp_2->kind != is_EDiff )
      {
        printf("Erro: Condição do 'for' inválida. Deve ser uma expressão de comparação.\n");
        break;
    }
    else {
      printf("Condição do for válida\n");
    }
    visitExp(p->u.sfor_.exp_2);

    printf("Verificando comando de atualização do FOR\n");
    if (p->u.sfor_.exp_3->kind != is_EIncr &&
        p->u.sfor_.exp_3->kind != is_EAssSimpl &&
        p->u.sfor_.exp_3->kind != is_EIncrWithoutemicolon) 
    {
        printf("Erro: Atualização do 'for' inválida. Deve ser uma expressão de incremento, decremento ou atribuição.\n");
        break;
    }
    else {
      printf("Atualização do for válida\n");
    }
    visitExp(p->u.sfor_.exp_3);

    printf("Executando o bloco do FOR\n");
    visitStm(p->u.sfor_.stm_);
    break;
  case is_SIf:
    /* Code for SIf Goes Here */
    printf("Visitando comando IF.\n");

    visitExp(p->u.sif_.exp_);

    
    if (p->u.sif_.exp_->kind != is_ELt &&   
        p->u.sif_.exp_->kind != is_Equal &&  
        p->u.sif_.exp_->kind != is_EDiff )
    {
        printf("Erro: Condição do 'if' inválida. Deve ser uma expressão de comparação.\n");
        break;
    }

    printf("Condição válida. Executando o bloco do IF.\n");
    
    visitListStm(p->u.sif_.liststm_);
    break;
  case is_SIfelse:
    /* Code for SIfelse Goes Here */
    printf("Visitando comando IF-ELSE.\n");

    if (p->u.sifelse_.exp_->kind != is_ELt &&   
        p->u.sifelse_.exp_->kind != is_Equal &&  
        p->u.sifelse_.exp_->kind != is_EDiff )
    {
      printf("Erro: Condição do 'if' inválida. Deve ser uma expressão de comparação.\n");
      break;
    }
    printf("Condição válida. Executando o bloco do IF.\n");
    /*visitExp(p->u.sifelse_.exp_);*/
    visitListStm(p->u.sifelse_.liststm_1);
    printf("Executando o bloco do ELSE.\n");
    visitListStm(p->u.sifelse_.liststm_2);
    break;
  case is_SReturn:
    /* Code for SReturn Goes Here */
    visitExp(p->u.sreturn_.exp_);
    break;
  case is_SLabel:
    /* Code for SLabel Goes Here */
    visitInteger(p->u.slabel_.integer_);
    break;
  case is_SGoto:
    /* Code for SGoto Goes Here */
    visitInteger(p->u.sgoto_.integer_);
    break;
  case is_SLog:
    /* Code for SLog Goes Here */
    printf("Visitando comando LOG.\n");

    printf("Validando o argumento do LOG...\n");
    switch (p->u.slog_.exp_->kind)
    {
    case is_EIdent:
        printf("LOG: Variável detectada.\n");
        visitIdent(p->u.slog_.exp_->u.eident_.ident_);
        printf("LOG válido.\n");
        break;

    case is_EStr:
        printf("LOG: String detectada.\n");
        visitString(p->u.slog_.exp_->u.estr_.string_);
        printf("LOG válido.\n");
        break;

    case is_Call:
        printf("LOG: Função detectada.\n");
        visitIdent(p->u.slog_.exp_->u.call_.ident_);
        visitListExp(p->u.slog_.exp_->u.call_.listexp_);
        printf("LOG válido.\n");
        break;
    default:
        printf("Erro: Argumento inválido para o comando LOG.\n");
        break;
    }
    /*visitExp(p->u.slog_.exp_);*/
    break;
  case is_SInterface:
    /* Code for SInterface Goes Here */
    visitIdent(p->u.sinterface_.ident_);
    visitListExp(p->u.sinterface_.listexp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Stm!\n");
    exit(1);
  }
}

void visitExp(Exp p)
{
  switch(p->kind)
  {
  case is_EAss:
    /* Code for EAss Goes Here */
    visitIdent(p->u.eass_.ident_);
    visitType(p->u.eass_.type_);
    visitExp(p->u.eass_.exp_);
    break;
  case is_EIdent:
    /* Code for EIdent Goes Here */
    visitIdent(p->u.eident_.ident_);
    break;
  case is_EAssSimpl:
    /* Code for EAssSimpl Goes Here */
    visitIdent(p->u.easssimpl_.ident_);
    visitExp(p->u.easssimpl_.exp_);
    break;
  case is_EConst:
    /* Code for EConst Goes Here */
    visitIdent(p->u.econst_.ident_);
    visitType(p->u.econst_.type_);
    visitExp(p->u.econst_.exp_);
    break;
  case is_EPontMem:
    /* Code for EPontMem Goes Here */
    visitTypont(p->u.epontmem_.typont_);
    visitIdent(p->u.epontmem_.ident_);
    visitExp(p->u.epontmem_.exp_);
    break;
  case is_EPont:
    /* Code for EPont Goes Here */
    visitTypont(p->u.epont_.typont_);
    visitIdent(p->u.epont_.ident_);
    visitExp(p->u.epont_.exp_);
    break;
  case is_EAssArray:
    /* Code for EAssArray Goes Here */
    visitIdent(p->u.eassarray_.ident_);
    visitType(p->u.eassarray_.type_);
    visitListExp(p->u.eassarray_.listexp_);
    break;
  case is_EAssArraySim:
    /* Code for EAssArraySim Goes Here */
    visitIdent(p->u.eassarraysim_.ident_);
    visitExp(p->u.eassarraysim_.exp_1);
    visitExp(p->u.eassarraysim_.exp_2);
    break;
  case is_EAPositionInArray:
    /* Code for EAPositionInArray Goes Here */
    visitIdent(p->u.eapositioninarray_.ident_1);
    visitInteger(p->u.eapositioninarray_.integer_1);
    visitIdent(p->u.eapositioninarray_.ident_2);
    visitInteger(p->u.eapositioninarray_.integer_2);
    break;
  case is_EAnotherArrayIndex:
    /* Code for EAnotherArrayIndex Goes Here */
    visitIdent(p->u.eanotherarrayindex_.ident_1);
    visitExp(p->u.eanotherarrayindex_.exp_1);
    visitIdent(p->u.eanotherarrayindex_.ident_2);
    visitExp(p->u.eanotherarrayindex_.exp_2);
    break;
  case is_EAssMatrix:
    /* Code for EAssMatrix Goes Here */
    visitIdent(p->u.eassmatrix_.ident_);
    visitType(p->u.eassmatrix_.type_);
    visitListExp(p->u.eassmatrix_.listexp_);
    break;
  case is_EAssMatrixOp:
    /* Code for EAssMatrixOp Goes Here */
    visitIdent(p->u.eassmatrixop_.ident_);
    visitType(p->u.eassmatrixop_.type_);
    visitExp(p->u.eassmatrixop_.exp_);
    break;
  case is_EAssInterface:
    /* Code for EAssInterface Goes Here */
    visitIdent(p->u.eassinterface_.ident_);
    visitType(p->u.eassinterface_.type_);
    visitListExp(p->u.eassinterface_.listexp_);
    break;
  case is_EkeyDecl:
    /* Code for EkeyDecl Goes Here */
    visitIdent(p->u.ekeydecl_.ident_);
    visitType(p->u.ekeydecl_.type_);
    break;
  case is_EkeyDeclObj:
    /* Code for EkeyDeclObj Goes Here */
    visitIdent(p->u.ekeydeclobj_.ident_);
    visitExp(p->u.ekeydeclobj_.exp_);
    break;
  case is_EIncr:
    /* Code for EIncr Goes Here */
    visitExp(p->u.eincr_.exp_);
    break;
  case is_EDecr:
    /* Code for EDecr Goes Here */
    visitExp(p->u.edecr_.exp_);
    break;
  case is_EIncrWithoutemicolon:
    /* Code for EIncrWithoutemicolon Goes Here */
    visitIdent(p->u.eincrwithoutemicolon_.ident_);
    break;
  case is_EDecrWithoutemicolon:
    /* Code for EDecrWithoutemicolon Goes Here */
    visitIdent(p->u.edecrwithoutemicolon_.ident_);
    break;
  case is_ExpList:
    /* Code for ExpList Goes Here */
    visitListExp(p->u.explist_.listexp_);
    break;
  case is_EMinor:
    /* Code for EMinor Goes Here */
    visitIdent(p->u.eminor_.ident_);
    visitExp(p->u.eminor_.exp_1);
    visitExp(p->u.eminor_.exp_2);
    break;
  case is_EVequal:
    /* Code for EVequal Goes Here */
    visitIdent(p->u.evequal_.ident_);
    visitExp(p->u.evequal_.exp_1);
    visitExp(p->u.evequal_.exp_2);
    break;
  case is_EVatri:
    /* Code for EVatri Goes Here */
    visitIdent(p->u.evatri_.ident_1);
    visitIdent(p->u.evatri_.ident_2);
    visitExp(p->u.evatri_.exp_);
    break;
  case is_ELt:
    /* Code for ELt Goes Here */
    visitExp(p->u.elt_.exp_1);
    visitExp(p->u.elt_.exp_2);
    break;
  case is_Equal:
    /* Code for Equal Goes Here */
    visitExp(p->u.equal_.exp_1);
    visitExp(p->u.equal_.exp_2);
    break;
  case is_EDiff:
    /* Code for EDiff Goes Here */
    visitExp(p->u.ediff_.exp_1);
    visitExp(p->u.ediff_.exp_2);
    break;
  case is_EAdd:
    /* Code for EAdd Goes Here */
    visitExp(p->u.eadd_.exp_1);
    visitExp(p->u.eadd_.exp_2);
    break;
  case is_ESub:
    /* Code for ESub Goes Here */
    visitExp(p->u.esub_.exp_1);
    visitExp(p->u.esub_.exp_2);
    break;
  case is_EMul:
    /* Code for EMul Goes Here */
    visitExp(p->u.emul_.exp_1);
    visitExp(p->u.emul_.exp_2);
    break;
  case is_Call:
    /* Code for Call Goes Here */
    visitIdent(p->u.call_.ident_);
    visitListExp(p->u.call_.listexp_);
    break;
  case is_EVar:
    /* Code for EVar Goes Here */
    visitIdent(p->u.evar_.ident_);
    break;
  case is_EStr:
    /* Code for EStr Goes Here */
    visitString(p->u.estr_.string_);
    break;
  case is_EInt:
    /* Code for EInt Goes Here */
    printf("Expressão inteira detectada: ");
    visitInteger(p->u.eint_.integer_);
    visitInteger(p->u.eint_.integer_);
    break;
  case is_EChar:
    /* Code for EChar Goes Here */
    visitChar(p->u.echar_.char_);
    break;
  case is_EDouble:
    /* Code for EDouble Goes Here */
    visitDouble(p->u.edouble_.double_);
    break;
  case is_EVet:
    /* Code for EVet Goes Here */
    visitIdent(p->u.evet_.ident_1);
    visitIdent(p->u.evet_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Exp!\n");
    exit(1);
  }
}

void visitListExp(ListExp listexp)
{
  while(listexp  != 0)
  {
    /* Code For ListExp Goes Here */
    visitExp(listexp->exp_);
    listexp = listexp->listexp_;
  }
}

void visitType(Type p)
{
  switch(p->kind)
  {
  case is_Type1:
    /* Code for Type1 Goes Here */
    visitType(p->u.type1_.type_);
    visitInteger(p->u.type1_.integer_);
    break;
  case is_Type_int:
    /* Code for Type_int Goes Here */
    break;
  case is_Type2:
    /* Code for Type2 Goes Here */
    visitString(p->u.type2_.string_);
    break;
  case is_Type_string:
    /* Code for Type_string Goes Here */
    break;
  case is_Type_float:
    /* Code for Type_float Goes Here */
    break;
  case is_Type_double:
    /* Code for Type_double Goes Here */
    break;
  case is_Type_char:
    /* Code for Type_char Goes Here */
    break;
  case is_Type_interface:
    /* Code for Type_interface Goes Here */
    break;
  case is_TypeIdent:
    /* Code for TypeIdent Goes Here */
    visitIdent(p->u.typeident_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Type!\n");
    exit(1);
  }
}

void visitTypont(Typont p)
{
  switch(p->kind)
  {
  case is_TPonterio:
    /* Code for TPonterio Goes Here */
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Typont!\n");
    exit(1);
  }
}

void visitIdent(Ident i)
{
  /* Code for Ident Goes Here */
}
void visitInteger(Integer i)
{
  /* Code for Integer Goes Here */
  /*printf("%d\n", i);  */
}
void visitDouble(Double d)
{
  /* Code for Double Goes Here */
}
void visitChar(Char c)
{
  /* Code for Char Goes Here */
}
void visitString(String s)
{
  /* Code for String Goes Here */
}

